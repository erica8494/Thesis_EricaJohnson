head(df, 25)
plot(sim, y = c("s.num", "i.num", "r.num"), legend = "full")
param <- param.dcm(beta = 0.5,
k = 5e5,
gamma = 1/10,
xi = 10,
delta = 1/3)
param <- param.dcm(beta = 0.5,
k = 1e5,
gamma = 1/10,
xi = 10,
delta = 1/3)
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 25)
# Plot the results for humans and the reservoir size separately
plot(sim, y = c("s.num", "i.num", "r.num"), legend = "full")
eMod2 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
# Total population size
num <- s.num + i.num + r.num
# Define lambdas
lambda.direct <- beta.direct * i.num
lambda.envirn <- beta.envirn * e.num
# Differential equations
dS <- -lambda.direct*s.num - lambda.envirn*s.num
dI <- lambda.direct*s.num + lambda.envirn*s.num - gamma*i.num
dR <- gamma*i.num
dE <- xi*i.num - delta*e.num
# Outputs
list(c(dS, dI, dR, dE))
})
}
# Parameterize the model with the following parameters this time
param <- param.dcm(beta.direct = 0.0001,
beta.envirn = 0.00001,
mu = 0.01,
gamma = 0.2,
xi = 2,
delta = 0.5)
# Use similar initial conditions and control settings as the first model, but
# make sure to update the new.mod function name!
init <- init.dcm(s.num = 10000, i.num = 1, r.num = 0, e.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = eMod2)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 25)
par(mar = c(3,3,1,1), mgp = c(2,1,0))
plot(sim, y = c("s.num", "i.num", "r.num"), legend = "full")
plot(sim, y = "e.num")
plot(sim, y = c("s.num", "i.num", "r.num"), legend = "full")
total_inf = sum(df$i.num)
mutate_epi(sim, direct =lambda.direct*s.num)
mutate_epi(sim, indirect =lambda.envirn*s.num)
eMod2 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
# Total population size
num <- s.num + i.num + r.num
# Define lambdas
lambda.direct <- beta.direct * i.num
lambda.envirn <- beta.envirn * e.num
# Differential equations
dS <- -lambda.direct*s.num - lambda.envirn*s.num
dI <- lambda.direct*s.num + lambda.envirn*s.num - gamma*i.num
dR <- gamma*i.num
dE <- xi*i.num - delta*e.num
# Outputs
list(c(dS, dI, dR, dE,
direct =lambda.direct*s.num,
indirect =lambda.envirn*s.num))
})
}
# Parameterize the model with the following parameters this time
param <- param.dcm(beta.direct = 0.0001,
beta.envirn = 0.00001,
mu = 0.01,
gamma = 0.2,
xi = 2,
delta = 0.5)
# Use similar initial conditions and control settings as the first model, but
# make sure to update the new.mod function name!
init <- init.dcm(s.num = 10000, i.num = 1, r.num = 0, e.num = 0, direct = 0,
indirect= 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = eMod2)
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 25)
total_inf = sum(df$i.num)
total_direct = sum(df$direct)
total_indirect = sum(df$indirect)
frac_direct = total_direct/total_inf
frac_indirect = total_indirect/total_inf
eMod2 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
# Total population size
num <- s.num + i.num + r.num
# Define lambdas
lambda.direct <- beta.direct * i.num
lambda.envirn <- beta.envirn * e.num
# Differential equations
dS <- -lambda.direct*s.num - lambda.envirn*s.num
dI <- lambda.direct*s.num + lambda.envirn*s.num - gamma*i.num
dR <- gamma*i.num
dE <- xi*i.num - delta*e.num
# Outputs
list(c(dS, dI, dR, dE))
})
}
init <- init.dcm(s.num = 10000, i.num = 1, r.num = 0, e.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = eMod2)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 25)
total_inf = sum(df$i.num)
eMod2 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
# Total population size
num <- s.num + i.num + r.num
# Define lambdas
lambda.direct <- beta.direct * i.num
lambda.envirn <- beta.envirn * e.num
# Differential equations
dS <- -lambda.direct*s.num - lambda.envirn*s.num
dI <- lambda.direct*s.num + lambda.envirn*s.num - gamma*i.num
dR <- gamma*i.num
dE <- xi*i.num - delta*e.num
# Outputs
list(c(dS, dI, dR, dE,
direct.flow =lambda.direct*s.num,
indirect.flow =lambda.envirn*s.num))
})
}
# Parameterize the model with the following parameters this time
param <- param.dcm(beta.direct = 0.0001,
beta.envirn = 0.00001,
mu = 0.01,
gamma = 0.2,
xi = 2,
delta = 0.5)
# Use similar initial conditions and control settings as the first model, but
# make sure to update the new.mod function name!
init <- init.dcm(s.num = 10000, i.num = 1, r.num = 0, e.num = 0, direct.flow = 0,
indirect.flow= 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = eMod2)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 25)
# Plot the results, including the two flow sizes
par(mar = c(3,3,1,1), mgp = c(2,1,0))
plot(sim, y = c("s.num", "i.num", "r.num"), legend = "full")
plot(sim, y = "e.num")
# Calculate the population attributable fraction of infections due to direct
# versus environmental transmission.
total_inf = sum(df$i.num)
total_direct = sum(df$direct)
total_indirect = sum(df$indirect)
frac_direct = total_direct/total_inf
frac_indirect = total_indirect/total_inf
total_inf = sum(df$i.num)
total_direct = sum(df$direc.flowt)
total_indirect = sum(df$indirect.flow)
frac_direct = total_direct/total_inf
frac_indirect = total_indirect/total_inf
total_inf = sum(df$direct.flow + df$indirect.flow)
total_direct = sum(df$direc.flow)
total_indirect = sum(df$indirect.flow)
frac_indirect = total_indirect/total_inf
frac_direct = total_direct/total_inf
total_inf = sum(df$direct.flow + df$indirect.flow)
total_direct = sum(df$direc.flow)
total_indirect = sum(df$indirect.flow)
frac_direct = total_direct/total_inf
sum(df$direct.flow)/total_inf
sum(df$indirect.flow)/total_inf
vMod1 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
#start of intervention
if (ih.num >= 50){
gamma = gamma*.5
}
# Total human/vector population size
num_h <- sh.num + ih.num + rh.num
num_v <- sv.num + iv.num
# Define lambdas
lambda.h <- beta.h * iv.num
lambda.v <- beta.v * ih.num
# Differential equations
dSh <- -lambda.h*sh.num + sigma.h*rh.num
dIh <- lambda.h*sh.num - gamma.h*ih.num
dRh <- gamma.h*ih.num - sigma.h*rh.num
dSv <- -lambda.v*sv.num + nu.v - mu.v*sv.num
dIv <- lambda.v*sv.num - mu.v*iv.num
# Outputs
list(c(dSh, dIh, dRh, dSv, dIv),
nu.v = nu.v)
})
}
param <- param.dcm(beta.h = 0.002,
beta.v = 0.002,
gamma.h = 1,
sigma.h = 0.1,
nu.v = 100,
mu.v = 0.1)
init <- init.dcm(sh.num = 1000, ih.num = 1, rh.num = 0,
sv.num = 1000, iv.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = vMod1)
sim <- dcm(param, init, control)
vMod1 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
#start of intervention
if (ih.num >= 50){
gamma.h = gamma.h*.5
}
# Total human/vector population size
num_h <- sh.num + ih.num + rh.num
num_v <- sv.num + iv.num
# Define lambdas
lambda.h <- beta.h * iv.num
lambda.v <- beta.v * ih.num
# Differential equations
dSh <- -lambda.h*sh.num + sigma.h*rh.num
dIh <- lambda.h*sh.num - gamma.h*ih.num
dRh <- gamma.h*ih.num - sigma.h*rh.num
dSv <- -lambda.v*sv.num + nu.v - mu.v*sv.num
dIv <- lambda.v*sv.num - mu.v*iv.num
# Outputs
list(c(dSh, dIh, dRh, dSv, dIv),
nu.v = nu.v)
})
}
param <- param.dcm(beta.h = 0.002,
beta.v = 0.002,
gamma.h = 1,
sigma.h = 0.1,
nu.v = 100,
mu.v = 0.1)
init <- init.dcm(sh.num = 1000, ih.num = 1, rh.num = 0,
sv.num = 1000, iv.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = vMod1)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 50)
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
vMod1 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
#start of intervention
if (ih.num >= 50){
beta.h = beta.h*.5
}
# Total human/vector population size
num_h <- sh.num + ih.num + rh.num
num_v <- sv.num + iv.num
# Define lambdas
lambda.h <- beta.h * iv.num
lambda.v <- beta.v * ih.num
# Differential equations
dSh <- -lambda.h*sh.num + sigma.h*rh.num
dIh <- lambda.h*sh.num - gamma.h*ih.num
dRh <- gamma.h*ih.num - sigma.h*rh.num
dSv <- -lambda.v*sv.num + nu.v - mu.v*sv.num
dIv <- lambda.v*sv.num - mu.v*iv.num
# Outputs
list(c(dSh, dIh, dRh, dSv, dIv),
nu.v = nu.v)
})
}
param <- param.dcm(beta.h = 0.002,
beta.v = 0.002,
gamma.h = 1,
sigma.h = 0.1,
nu.v = 100,
mu.v = 0.1)
init <- init.dcm(sh.num = 1000, ih.num = 1, rh.num = 0,
sv.num = 1000, iv.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = vMod1)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 50)
# Plot the results
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
plot(sim, y = c("ih.num", "iv.num"), legend = "full")
# Plot the results
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
# Plot the results
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
vMod1 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
#start of intervention
# if (ih.num >= 50){
#   beta.h = beta.h*.5
# }
# Total human/vector population size
num_h <- sh.num + ih.num + rh.num
num_v <- sv.num + iv.num
# Define lambdas
lambda.h <- beta.h * iv.num
lambda.v <- beta.v * ih.num
# Differential equations
dSh <- -lambda.h*sh.num + sigma.h*rh.num
dIh <- lambda.h*sh.num - gamma.h*ih.num
dRh <- gamma.h*ih.num - sigma.h*rh.num
dSv <- -lambda.v*sv.num + nu.v - mu.v*sv.num
dIv <- lambda.v*sv.num - mu.v*iv.num
# Outputs
list(c(dSh, dIh, dRh, dSv, dIv),
nu.v = nu.v)
})
}
param <- param.dcm(beta.h = 0.002,
beta.v = 0.002,
gamma.h = 1,
sigma.h = 0.1,
nu.v = 100,
mu.v = 0.1)
init <- init.dcm(sh.num = 1000, ih.num = 1, rh.num = 0,
sv.num = 1000, iv.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = vMod1)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 50)
# Plot the results
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
plot(sim, y = c("ih.num", "iv.num"), legend = "full")
# Plot the results
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
vMod1 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
start of intervention
if (ih.num >= 50){
beta.h = beta.h*.5
}
# Total human/vector population size
num_h <- sh.num + ih.num + rh.num
num_v <- sv.num + iv.num
# Define lambdas
lambda.h <- beta.h * iv.num
lambda.v <- beta.v * ih.num
# Differential equations
dSh <- -lambda.h*sh.num + sigma.h*rh.num
dIh <- lambda.h*sh.num - gamma.h*ih.num
dRh <- gamma.h*ih.num - sigma.h*rh.num
dSv <- -lambda.v*sv.num + nu.v - mu.v*sv.num
dIv <- lambda.v*sv.num - mu.v*iv.num
# Outputs
list(c(dSh, dIh, dRh, dSv, dIv),
nu.v = nu.v)
})
}
vMod1 <- function(t, t0, parms) {
with(as.list(c(t0, parms)), {
#start of intervention
if (ih.num >= 50){
beta.h = beta.h*.5
}
# Total human/vector population size
num_h <- sh.num + ih.num + rh.num
num_v <- sv.num + iv.num
# Define lambdas
lambda.h <- beta.h * iv.num
lambda.v <- beta.v * ih.num
# Differential equations
dSh <- -lambda.h*sh.num + sigma.h*rh.num
dIh <- lambda.h*sh.num - gamma.h*ih.num
dRh <- gamma.h*ih.num - sigma.h*rh.num
dSv <- -lambda.v*sv.num + nu.v - mu.v*sv.num
dIv <- lambda.v*sv.num - mu.v*iv.num
# Outputs
list(c(dSh, dIh, dRh, dSv, dIv),
nu.v = nu.v)
})
}
param <- param.dcm(beta.h = 0.002,
beta.v = 0.002,
gamma.h = 1,
sigma.h = 0.1,
nu.v = 100,
mu.v = 0.1)
init <- init.dcm(sh.num = 1000, ih.num = 1, rh.num = 0,
sv.num = 1000, iv.num = 0)
control <- control.dcm(nsteps = 100, dt = 0.1, new.mod = vMod1)
# Run the simulation and examine the output as a data frame
sim <- dcm(param, init, control)
df <- as.data.frame(sim)
head(df, 50)
# Plot the results
plot(sim, y = c("sh.num", "ih.num", "rh.num"), legend = "full")
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra); library(tidyverse)
install.packages("kableExtra");install.packages("tidyverse")
install.packages("kableExtra");install.packages("tidyverse")
library(kableExtra); library(tidyverse)
library(kableExtra); library(tidyverse)
dt <- tibble(
Items = c("$\beta_{alive}$", "Item 2", "Item 3"),
Text_1 = c("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin vehicula tempor ex. Morbi malesuada sagittis turpis, at venenatis nisl luctus a. ","In eu urna at magna luctus rhoncus quis in nisl. Fusce in velit varius, posuere risus et, cursus augue. Duis eleifend aliquam ante, a aliquet ex tincidunt in. ", "Vivamus venenatis egestas eros ut tempus. Vivamus id est nisi. Aliquam molestie erat et sollicitudin venenatis. In ac lacus at velit scelerisque mattis. "),
Text_2 = c( "xx","xc","df")
)
dt <- tibble(
Items = c("$\beta_{alive}$", "Item 2", "Item 3"),
Text_1 = c("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin vehicula tempor ex. Morbi malesuada sagittis turpis, at venenatis nisl luctus a. ","In eu urna at magna luctus rhoncus quis in nisl. Fusce in velit varius, posuere risus et, cursus augue. Duis eleifend aliquam ante, a aliquet ex tincidunt in. ", "Vivamus venenatis egestas eros ut tempus. Vivamus id est nisi. Aliquam molestie erat et sollicitudin venenatis. In ac lacus at velit scelerisque mattis. "),
Text_2 = c( "xx","xc","df")
)
kable(dt, "latex", booktabs = T,
col.names = c("Item", "Short Title", "Very Very Very Very Very Very Long Title")) %>%
column_spec(2:3, width = "5cm")
dt <- tibble(
Items = c("$\beta_{alive}$", "Item 2", "Item 3"),
Text_1 = c("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin vehicula tempor ex. Morbi malesuada sagittis turpis, at venenatis nisl luctus a. ","In eu urna at magna luctus rhoncus quis in nisl. Fusce in velit varius, posuere risus et, cursus augue. Duis eleifend aliquam ante, a aliquet ex tincidunt in. ", "Vivamus venenatis egestas eros ut tempus. Vivamus id est nisi. Aliquam molestie erat et sollicitudin venenatis. In ac lacus at velit scelerisque mattis. "),
Text_2 = c( "xx","xc","df")
)
kable(dt, "latex", booktabs = T,
col.names = c("Item", "Short Title", "Very Very Very Very Very Very Long Title")) %>%
column_spec(2:3, width = "5cm")
View(dt)
knitr::opts_chunk$set(echo = TRUE)
df = 0
df$r1 = c(-0.5,0.1,0.2)
df$r1 = c(0.1,0.2,0.3)
df = 0
df$r1 = c(-0.5,0.1,0.2)
df$r1 = c(0.1,0.2,0.3)
df = 0
df$r1 = c(-0.5,0.1,0.2)
df$r2 = c(0.1,0.2,0.3)
df1 = matrix(data = c(-0.5,0.1,0.2;0.1,0.2,0.3), ncol = 2)
df1 = matrix(data = c(-0.5,0.1,0.2,0.1,0.2,0.3), nrow = 3)
df1 = matrix(data = c(-0.5,0.1,0.2,0.1,0.2,0.3), nrow = 3)
View(df1)
df1 = matrix(data = c(-0.5,0.1,0.2,0.1,0.2,0.3), ncol = 3)
View(df1)
df2 = matrix(data = c(0.5,1,2), ncol = 3)
df3 = matrix(data = c(1,5,2), ncol = 1)
View(df3)
df4 = df1%*%df3
View(df4)
View(df4)
View(df4)
df5 = matrix(data = c(1,0.9,1.2))
View(df5)
df6 = df5%*%df2
df1 = matrix(data = c(-0.5,0.1,0.2,0.1,0.2,0.3), ncol = 3)
df2 = matrix(data = c(0.5,1,2), ncol = 3)
df3 = matrix(data = c(1,5,2), ncol = 1)
df4 = df1%*%df3
df4
df5 = matrix(data = c(1,0.9,1.2))
df6 = df5%*%df2
df6
df6 = df5%*%df2
View(df6)
df6 = df5%*%t(df2)
View(df1)
View(df3)
View(df5)
View(df2)
CI_U = 0.22204 + 1.980*
MSE = (490.91984-280.91916)/652
CI_U = 0.22204 + 1.980*
MSE = (490.91984-280.91916)/652
CI_U = 0.22204 + 1.980
MSE = (490.91984-280.91916)/652
MSE
39.4790/12
39.4790*0.1036
sqrt(39.4790)/12
sqrt(39.4790)/10
315.75/3/14
39.4790/10/2/11
39.4790/10/2/12
39.4790/12/2/12
39.4790/10/2/(12*11)
knitr::opts_chunk$set(echo = TRUE)
1-pnorm(3.54012587498)
1-pbinom(25,373,3,407/102,370) 
1-pbinom(25,373,3,407/102,370)
1-pbinom(25,373,3,407/102,370)
1-pbinom(25,373,3,407/102370)
1-pbinom(25,373,3407/102370)
binom.test(25, 373)$conf.int
setwd("/Users/Erica/Desktop/R_Files/Thesis")
getwd()
install.packages('tidyverse')
install.packages(c('pacman', 'here'))
install.packages(c('tinytex', 'rmarkdown', 'knitr'))
tinytex::install_tinytex()
tinytex::install_tinytex()
# this function installs the tinytex LaTex on your
#  computer which is necessary for rendering (creating) PDF's
install.packages(c('tidycensus','tigris'))
install.packages(c('sp', 'sf', 'rgdal', 'raster', 'RColorBrewer', 'rgeos', 'maptools', 'OpenStreetMap'))
install.packages(c('tmap', 'tmaptools', 'ggmap', 'shinyjs', 'shiny', 'micromap'))
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library(rio)
install.packages('rio')
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library(rio)
x <- data.frame("SN" = 1:5, "Age" = c(21,15, 20, 30, 31), "Name" = c("John","Dora", "Joe", "Denise", "Jamie"))
plot(x$Age)
#subset to only first obs (since characteristics only taken at baseline)
x2 <- x%>%
mutate(random = SN + Age)
View(x2)
